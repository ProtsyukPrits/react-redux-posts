{"ast":null,"code":"import _objectSpread from \"/home/dmytro/react-redux-posts/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/dmytro/react-redux-posts/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _slicedToArray from \"/home/dmytro/react-redux-posts/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _excluded = [\"transition\", \"transitionEnd\"];\nimport { startAnimation } from '../../animation/utils/transitions.mjs';\nimport { setTarget } from './setters.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { transformProps } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\n\nfunction animateVisualElement(visualElement, definition) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  visualElement.notify(\"AnimationStart\", definition);\n  var animation;\n\n  if (Array.isArray(definition)) {\n    var animations = definition.map(function (variant) {\n      return animateVariant(visualElement, variant, options);\n    });\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n\n  return animation.then(function () {\n    return visualElement.notify(\"AnimationComplete\", definition);\n  });\n}\n\nfunction animateVariant(visualElement, variant) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  var resolved = resolveVariant(visualElement, variant, options.custom);\n\n  var _ref = resolved || {},\n      _ref$transition = _ref.transition,\n      transition = _ref$transition === void 0 ? visualElement.getDefaultTransition() || {} : _ref$transition;\n\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n\n  var getAnimation = resolved ? function () {\n    return animateTarget(visualElement, resolved, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n  var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function () {\n    var forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var _transition = transition,\n        _transition$delayChil = _transition.delayChildren,\n        delayChildren = _transition$delayChil === void 0 ? 0 : _transition$delayChil,\n        staggerChildren = _transition.staggerChildren,\n        staggerDirection = _transition.staggerDirection;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n\n  var _transition2 = transition,\n      when = _transition2.when;\n\n  if (when) {\n    var _ref2 = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation],\n        _ref3 = _slicedToArray(_ref2, 2),\n        first = _ref3[0],\n        last = _ref3[1];\n\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\n * @internal\n */\n\n\nfunction animateTarget(visualElement, definition) {\n  var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref4$delay = _ref4.delay,\n      delay = _ref4$delay === void 0 ? 0 : _ref4$delay,\n      transitionOverride = _ref4.transitionOverride,\n      type = _ref4.type;\n\n  var _a;\n\n  var _visualElement$makeTa = visualElement.makeTargetAnimatable(definition),\n      _visualElement$makeTa2 = _visualElement$makeTa.transition,\n      transition = _visualElement$makeTa2 === void 0 ? visualElement.getDefaultTransition() : _visualElement$makeTa2,\n      transitionEnd = _visualElement$makeTa.transitionEnd,\n      target = _objectWithoutProperties(_visualElement$makeTa, _excluded);\n\n  var willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride) transition = transitionOverride;\n  var animations = [];\n  var animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n\n  var _loop = function _loop(key) {\n    var value = visualElement.getValue(key);\n    var valueTarget = target[key];\n\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      return \"continue\";\n    }\n\n    var valueTransition = _objectSpread({\n      delay: delay\n    }, transition);\n    /**\n     * Make animation instant if this is a transform prop and we should reduce motion.\n     */\n\n\n    if (visualElement.shouldReduceMotion && transformProps.has(key)) {\n      valueTransition = _objectSpread(_objectSpread({}, valueTransition), {}, {\n        type: false,\n        delay: 0\n      });\n    }\n\n    var animation = startAnimation(key, value, valueTarget, valueTransition);\n\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(function () {\n        return willChange.remove(key);\n      });\n    }\n\n    animations.push(animation);\n  };\n\n  for (var key in target) {\n    var _ret = _loop(key);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return Promise.all(animations).then(function () {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\n\nfunction animateChildren(visualElement, variant) {\n  var delayChildren = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var staggerChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var staggerDirection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var options = arguments.length > 5 ? arguments[5] : undefined;\n  var animations = [];\n  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function () {\n    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return i * staggerChildren;\n  } : function () {\n    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {\n    animations.push(animateVariant(child, variant, _objectSpread(_objectSpread({}, options), {}, {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(function () {\n      return child.notify(\"AnimationComplete\", variant);\n    }));\n  });\n  return Promise.all(animations);\n}\n\nfunction stopAnimation(visualElement) {\n  visualElement.values.forEach(function (value) {\n    return value.stop();\n  });\n}\n\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\n\n\nfunction shouldBlockAnimation(_ref5, key) {\n  var protectedKeys = _ref5.protectedKeys,\n      needsAnimating = _ref5.needsAnimating;\n  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };","map":{"version":3,"sources":["/home/dmytro/react-redux-posts/node_modules/framer-motion/dist/es/render/utils/animation.mjs"],"names":["startAnimation","setTarget","resolveVariant","transformProps","isWillChangeMotionValue","animateVisualElement","visualElement","definition","options","notify","animation","Array","isArray","animations","map","variant","animateVariant","Promise","all","resolvedDefinition","custom","animateTarget","then","_a","resolved","transition","getDefaultTransition","transitionOverride","getAnimation","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","first","last","delay","type","makeTargetAnimatable","transitionEnd","target","willChange","getValue","animationTypeState","animationState","getState","key","value","valueTarget","undefined","shouldBlockAnimation","valueTransition","shouldReduceMotion","has","add","remove","push","maxStaggerDuration","generateStaggerDuration","i","from","sort","sortByTreeOrder","forEach","child","stopAnimation","values","stop","a","b","sortNodePosition","protectedKeys","needsAnimating","shouldBlock","hasOwnProperty"],"mappings":"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","sourcesContent":["import { startAnimation } from '../../animation/utils/transitions.mjs';\nimport { setTarget } from './setters.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { transformProps } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify(\"AnimationStart\", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        const resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(() => visualElement.notify(\"AnimationComplete\", definition));\n}\nfunction animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, options.custom);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => animateTarget(visualElement, resolved, options)\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(last);\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, { delay = 0, transitionOverride, type } = {}) {\n    var _a;\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);\n    const willChange = visualElement.getValue(\"willChange\");\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n    for (const key in target) {\n        const value = visualElement.getValue(key);\n        const valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        let valueTransition = { delay, ...transition };\n        /**\n         * Make animation instant if this is a transform prop and we should reduce motion.\n         */\n        if (visualElement.shouldReduceMotion && transformProps.has(key)) {\n            valueTransition = {\n                ...valueTransition,\n                type: false,\n                delay: 0,\n            };\n        }\n        let animation = startAnimation(key, value, valueTarget, valueTransition);\n        if (isWillChangeMotionValue(willChange)) {\n            willChange.add(key);\n            animation = animation.then(() => willChange.remove(key));\n        }\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(() => {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value) => value.stop());\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\n\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };\n"]},"metadata":{},"sourceType":"module"}