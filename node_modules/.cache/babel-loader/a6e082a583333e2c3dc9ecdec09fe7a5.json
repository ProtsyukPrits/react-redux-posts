{"ast":null,"code":"\"use strict\";\n\nexports.areIntervalsOverlapping = areIntervalsOverlapping;\n\nvar _index = require(\"./toDate.js\");\n/**\n * The {@link areIntervalsOverlapping} function options.\n */\n\n/**\n * @name areIntervalsOverlapping\n * @category Interval Helpers\n * @summary Is the given time interval overlapping with another time interval?\n *\n * @description\n * Is the given time interval overlapping with another time interval? Adjacent intervals do not count as overlapping unless `inclusive` is set to `true`.\n *\n * @param intervalLeft - The first interval to compare.\n * @param intervalRight - The second interval to compare.\n * @param options - The object with options\n *\n * @returns Whether the time intervals are overlapping\n *\n * @example\n * // For overlapping time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }\n * )\n * //=> true\n *\n * @example\n * // For non-overlapping time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }\n * )\n * //=> false\n *\n * @example\n * // For adjacent time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 30) }\n * )\n * //=> false\n *\n * @example\n * // Using the inclusive option:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) }\n * )\n * //=> false\n *\n * @example\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) },\n *   { inclusive: true }\n * )\n * //=> true\n */\n\n\nfunction areIntervalsOverlapping(intervalLeft, intervalRight, options) {\n  const [leftStartTime, leftEndTime] = [+(0, _index.toDate)(intervalLeft.start), +(0, _index.toDate)(intervalLeft.end)].sort((a, b) => a - b);\n  const [rightStartTime, rightEndTime] = [+(0, _index.toDate)(intervalRight.start), +(0, _index.toDate)(intervalRight.end)].sort((a, b) => a - b);\n  if (options?.inclusive) return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;\n  return leftStartTime < rightEndTime && rightStartTime < leftEndTime;\n}","map":{"version":3,"sources":["/home/dmytro/react-redux-posts/node_modules/date-fns/areIntervalsOverlapping.js"],"names":["exports","areIntervalsOverlapping","_index","require","intervalLeft","intervalRight","options","leftStartTime","leftEndTime","toDate","start","end","sort","a","b","rightStartTime","rightEndTime","inclusive"],"mappings":"AAAA;;AACAA,OAAO,CAACC,uBAAR,GAAkCA,uBAAlC;;AACA,IAAIC,MAAM,GAAGC,OAAO,CAAC,aAAD,CAApB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,uBAAT,CAAiCG,YAAjC,EAA+CC,aAA/C,EAA8DC,OAA9D,EAAuE;AACrE,QAAM,CAACC,aAAD,EAAgBC,WAAhB,IAA+B,CACnC,CAAC,CAAC,GAAGN,MAAM,CAACO,MAAX,EAAmBL,YAAY,CAACM,KAAhC,CADkC,EAEnC,CAAC,CAAC,GAAGR,MAAM,CAACO,MAAX,EAAmBL,YAAY,CAACO,GAAhC,CAFkC,EAGnCC,IAHmC,CAG9B,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAHgB,CAArC;AAIA,QAAM,CAACC,cAAD,EAAiBC,YAAjB,IAAiC,CACrC,CAAC,CAAC,GAAGd,MAAM,CAACO,MAAX,EAAmBJ,aAAa,CAACK,KAAjC,CADoC,EAErC,CAAC,CAAC,GAAGR,MAAM,CAACO,MAAX,EAAmBJ,aAAa,CAACM,GAAjC,CAFoC,EAGrCC,IAHqC,CAGhC,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAHkB,CAAvC;AAKA,MAAIR,OAAO,EAAEW,SAAb,EACE,OAAOV,aAAa,IAAIS,YAAjB,IAAiCD,cAAc,IAAIP,WAA1D;AAEF,SAAOD,aAAa,GAAGS,YAAhB,IAAgCD,cAAc,GAAGP,WAAxD;AACD","sourcesContent":["\"use strict\";\nexports.areIntervalsOverlapping = areIntervalsOverlapping;\nvar _index = require(\"./toDate.js\");\n\n/**\n * The {@link areIntervalsOverlapping} function options.\n */\n\n/**\n * @name areIntervalsOverlapping\n * @category Interval Helpers\n * @summary Is the given time interval overlapping with another time interval?\n *\n * @description\n * Is the given time interval overlapping with another time interval? Adjacent intervals do not count as overlapping unless `inclusive` is set to `true`.\n *\n * @param intervalLeft - The first interval to compare.\n * @param intervalRight - The second interval to compare.\n * @param options - The object with options\n *\n * @returns Whether the time intervals are overlapping\n *\n * @example\n * // For overlapping time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }\n * )\n * //=> true\n *\n * @example\n * // For non-overlapping time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }\n * )\n * //=> false\n *\n * @example\n * // For adjacent time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 30) }\n * )\n * //=> false\n *\n * @example\n * // Using the inclusive option:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) }\n * )\n * //=> false\n *\n * @example\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) },\n *   { inclusive: true }\n * )\n * //=> true\n */\nfunction areIntervalsOverlapping(intervalLeft, intervalRight, options) {\n  const [leftStartTime, leftEndTime] = [\n    +(0, _index.toDate)(intervalLeft.start),\n    +(0, _index.toDate)(intervalLeft.end),\n  ].sort((a, b) => a - b);\n  const [rightStartTime, rightEndTime] = [\n    +(0, _index.toDate)(intervalRight.start),\n    +(0, _index.toDate)(intervalRight.end),\n  ].sort((a, b) => a - b);\n\n  if (options?.inclusive)\n    return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;\n\n  return leftStartTime < rightEndTime && rightStartTime < leftEndTime;\n}\n"]},"metadata":{},"sourceType":"script"}