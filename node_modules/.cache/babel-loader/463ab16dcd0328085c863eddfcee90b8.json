{"ast":null,"code":"\"use strict\";\n\nexports.lightFormat = lightFormat;\nObject.defineProperty(exports, \"lightFormatters\", {\n  enumerable: true,\n  get: function () {\n    return _index3.lightFormatters;\n  }\n});\n\nvar _index = require(\"./isValid.js\");\n\nvar _index2 = require(\"./toDate.js\");\n\nvar _index3 = require(\"./_lib/format/lightFormatters.js\"); // Rexports of internal for libraries to use.\n// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874\n// This RegExp consists of three parts separated by `|`:\n// - (\\w)\\1* matches any sequences of the same letter\n// - '' matches two quote characters in a row\n// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),\n//   except a single quote symbol, which ends the sequence.\n//   Two quote characters do not end the sequence.\n//   If there is no matching single quote\n//   then the sequence will continue until the end of the string.\n// - . matches any single character unmatched by previous parts of the RegExps\n\n\nconst formattingTokensRegExp = /(\\w)\\1*|''|'(''|[^'])+('|$)|./g;\nconst escapedStringRegExp = /^'([^]*?)'?$/;\nconst doubleQuoteRegExp = /''/g;\nconst unescapedLatinCharacterRegExp = /[a-zA-Z]/;\n/**\n * @private\n */\n\n/**\n * @name lightFormat\n * @category Common Helpers\n * @summary Format the date.\n *\n * @description\n * Return the formatted date string in the given format. Unlike `format`,\n * `lightFormat` doesn't use locales and outputs date using the most popular tokens.\n *\n * > ⚠️ Please note that the `lightFormat` tokens differ from Moment.js and other libraries.\n * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\n *\n * The characters wrapped between two single quotes characters (') are escaped.\n * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n *\n * Format of the string is based on Unicode Technical Standard #35:\n * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n *\n * Accepted patterns:\n * | Unit                            | Pattern | Result examples                   |\n * |---------------------------------|---------|-----------------------------------|\n * | AM, PM                          | a..aaa  | AM, PM                            |\n * |                                 | aaaa    | a.m., p.m.                        |\n * |                                 | aaaaa   | a, p                              |\n * | Calendar year                   | y       | 44, 1, 1900, 2017                 |\n * |                                 | yy      | 44, 01, 00, 17                    |\n * |                                 | yyy     | 044, 001, 000, 017                |\n * |                                 | yyyy    | 0044, 0001, 1900, 2017            |\n * | Month (formatting)              | M       | 1, 2, ..., 12                     |\n * |                                 | MM      | 01, 02, ..., 12                   |\n * | Day of month                    | d       | 1, 2, ..., 31                     |\n * |                                 | dd      | 01, 02, ..., 31                   |\n * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |\n * |                                 | hh      | 01, 02, ..., 11, 12               |\n * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |\n * |                                 | HH      | 00, 01, 02, ..., 23               |\n * | Minute                          | m       | 0, 1, ..., 59                     |\n * |                                 | mm      | 00, 01, ..., 59                   |\n * | Second                          | s       | 0, 1, ..., 59                     |\n * |                                 | ss      | 00, 01, ..., 59                   |\n * | Fraction of second              | S       | 0, 1, ..., 9                      |\n * |                                 | SS      | 00, 01, ..., 99                   |\n * |                                 | SSS     | 000, 001, ..., 999                |\n * |                                 | SSSS    | ...                               |\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n * @param format - The string of tokens\n *\n * @returns The formatted date string\n *\n * @throws `Invalid time value` if the date is invalid\n * @throws format string contains an unescaped latin alphabet character\n *\n * @example\n * const result = lightFormat(new Date(2014, 1, 11), 'yyyy-MM-dd')\n * //=> '2014-02-11'\n */\n\nfunction lightFormat(date, formatStr) {\n  const _date = (0, _index2.toDate)(date);\n\n  if (!(0, _index.isValid)(_date)) {\n    throw new RangeError(\"Invalid time value\");\n  }\n\n  const tokens = formatStr.match(formattingTokensRegExp); // The only case when formattingTokensRegExp doesn't match the string is when it's empty\n\n  if (!tokens) return \"\";\n  const result = tokens.map(substring => {\n    // Replace two single quote characters with one single quote character\n    if (substring === \"''\") {\n      return \"'\";\n    }\n\n    const firstCharacter = substring[0];\n\n    if (firstCharacter === \"'\") {\n      return cleanEscapedString(substring);\n    }\n\n    const formatter = _index3.lightFormatters[firstCharacter];\n\n    if (formatter) {\n      return formatter(_date, substring);\n    }\n\n    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {\n      throw new RangeError(\"Format string contains an unescaped latin alphabet character `\" + firstCharacter + \"`\");\n    }\n\n    return substring;\n  }).join(\"\");\n  return result;\n}\n\nfunction cleanEscapedString(input) {\n  const matches = input.match(escapedStringRegExp);\n\n  if (!matches) {\n    return input;\n  }\n\n  return matches[1].replace(doubleQuoteRegExp, \"'\");\n}","map":{"version":3,"sources":["/home/dmytro/react-redux-posts/node_modules/date-fns/lightFormat.js"],"names":["exports","lightFormat","Object","defineProperty","enumerable","get","_index3","lightFormatters","_index","require","_index2","formattingTokensRegExp","escapedStringRegExp","doubleQuoteRegExp","unescapedLatinCharacterRegExp","date","formatStr","_date","toDate","isValid","RangeError","tokens","match","result","map","substring","firstCharacter","cleanEscapedString","formatter","join","input","matches","replace"],"mappings":"AAAA;;AACAA,OAAO,CAACC,WAAR,GAAsBA,WAAtB;AACAC,MAAM,CAACC,cAAP,CAAsBH,OAAtB,EAA+B,iBAA/B,EAAkD;AAChDI,EAAAA,UAAU,EAAE,IADoC;AAEhDC,EAAAA,GAAG,EAAE,YAAY;AACf,WAAOC,OAAO,CAACC,eAAf;AACD;AAJ+C,CAAlD;;AAMA,IAAIC,MAAM,GAAGC,OAAO,CAAC,cAAD,CAApB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,aAAD,CAArB;;AACA,IAAIH,OAAO,GAAGG,OAAO,CAAC,kCAAD,CAArB,C,CAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,sBAAsB,GAAG,gCAA/B;AAEA,MAAMC,mBAAmB,GAAG,cAA5B;AACA,MAAMC,iBAAiB,GAAG,KAA1B;AACA,MAAMC,6BAA6B,GAAG,UAAtC;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASb,WAAT,CAAqBc,IAArB,EAA2BC,SAA3B,EAAsC;AACpC,QAAMC,KAAK,GAAG,CAAC,GAAGP,OAAO,CAACQ,MAAZ,EAAoBH,IAApB,CAAd;;AAEA,MAAI,CAAC,CAAC,GAAGP,MAAM,CAACW,OAAX,EAAoBF,KAApB,CAAL,EAAiC;AAC/B,UAAM,IAAIG,UAAJ,CAAe,oBAAf,CAAN;AACD;;AAED,QAAMC,MAAM,GAAGL,SAAS,CAACM,KAAV,CAAgBX,sBAAhB,CAAf,CAPoC,CASpC;;AACA,MAAI,CAACU,MAAL,EAAa,OAAO,EAAP;AAEb,QAAME,MAAM,GAAGF,MAAM,CAClBG,GADY,CACPC,SAAD,IAAe;AAClB;AACA,QAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtB,aAAO,GAAP;AACD;;AAED,UAAMC,cAAc,GAAGD,SAAS,CAAC,CAAD,CAAhC;;AACA,QAAIC,cAAc,KAAK,GAAvB,EAA4B;AAC1B,aAAOC,kBAAkB,CAACF,SAAD,CAAzB;AACD;;AAED,UAAMG,SAAS,GAAGtB,OAAO,CAACC,eAAR,CAAwBmB,cAAxB,CAAlB;;AACA,QAAIE,SAAJ,EAAe;AACb,aAAOA,SAAS,CAACX,KAAD,EAAQQ,SAAR,CAAhB;AACD;;AAED,QAAIC,cAAc,CAACJ,KAAf,CAAqBR,6BAArB,CAAJ,EAAyD;AACvD,YAAM,IAAIM,UAAJ,CACJ,mEACEM,cADF,GAEE,GAHE,CAAN;AAKD;;AAED,WAAOD,SAAP;AACD,GA1BY,EA2BZI,IA3BY,CA2BP,EA3BO,CAAf;AA6BA,SAAON,MAAP;AACD;;AAED,SAASI,kBAAT,CAA4BG,KAA5B,EAAmC;AACjC,QAAMC,OAAO,GAAGD,KAAK,CAACR,KAAN,CAAYV,mBAAZ,CAAhB;;AAEA,MAAI,CAACmB,OAAL,EAAc;AACZ,WAAOD,KAAP;AACD;;AAED,SAAOC,OAAO,CAAC,CAAD,CAAP,CAAWC,OAAX,CAAmBnB,iBAAnB,EAAsC,GAAtC,CAAP;AACD","sourcesContent":["\"use strict\";\nexports.lightFormat = lightFormat;\nObject.defineProperty(exports, \"lightFormatters\", {\n  enumerable: true,\n  get: function () {\n    return _index3.lightFormatters;\n  },\n});\nvar _index = require(\"./isValid.js\");\nvar _index2 = require(\"./toDate.js\");\nvar _index3 = require(\"./_lib/format/lightFormatters.js\");\n\n// Rexports of internal for libraries to use.\n// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874\n\n// This RegExp consists of three parts separated by `|`:\n// - (\\w)\\1* matches any sequences of the same letter\n// - '' matches two quote characters in a row\n// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),\n//   except a single quote symbol, which ends the sequence.\n//   Two quote characters do not end the sequence.\n//   If there is no matching single quote\n//   then the sequence will continue until the end of the string.\n// - . matches any single character unmatched by previous parts of the RegExps\nconst formattingTokensRegExp = /(\\w)\\1*|''|'(''|[^'])+('|$)|./g;\n\nconst escapedStringRegExp = /^'([^]*?)'?$/;\nconst doubleQuoteRegExp = /''/g;\nconst unescapedLatinCharacterRegExp = /[a-zA-Z]/;\n\n/**\n * @private\n */\n\n/**\n * @name lightFormat\n * @category Common Helpers\n * @summary Format the date.\n *\n * @description\n * Return the formatted date string in the given format. Unlike `format`,\n * `lightFormat` doesn't use locales and outputs date using the most popular tokens.\n *\n * > ⚠️ Please note that the `lightFormat` tokens differ from Moment.js and other libraries.\n * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md\n *\n * The characters wrapped between two single quotes characters (') are escaped.\n * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n *\n * Format of the string is based on Unicode Technical Standard #35:\n * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n *\n * Accepted patterns:\n * | Unit                            | Pattern | Result examples                   |\n * |---------------------------------|---------|-----------------------------------|\n * | AM, PM                          | a..aaa  | AM, PM                            |\n * |                                 | aaaa    | a.m., p.m.                        |\n * |                                 | aaaaa   | a, p                              |\n * | Calendar year                   | y       | 44, 1, 1900, 2017                 |\n * |                                 | yy      | 44, 01, 00, 17                    |\n * |                                 | yyy     | 044, 001, 000, 017                |\n * |                                 | yyyy    | 0044, 0001, 1900, 2017            |\n * | Month (formatting)              | M       | 1, 2, ..., 12                     |\n * |                                 | MM      | 01, 02, ..., 12                   |\n * | Day of month                    | d       | 1, 2, ..., 31                     |\n * |                                 | dd      | 01, 02, ..., 31                   |\n * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |\n * |                                 | hh      | 01, 02, ..., 11, 12               |\n * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |\n * |                                 | HH      | 00, 01, 02, ..., 23               |\n * | Minute                          | m       | 0, 1, ..., 59                     |\n * |                                 | mm      | 00, 01, ..., 59                   |\n * | Second                          | s       | 0, 1, ..., 59                     |\n * |                                 | ss      | 00, 01, ..., 59                   |\n * | Fraction of second              | S       | 0, 1, ..., 9                      |\n * |                                 | SS      | 00, 01, ..., 99                   |\n * |                                 | SSS     | 000, 001, ..., 999                |\n * |                                 | SSSS    | ...                               |\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n * @param format - The string of tokens\n *\n * @returns The formatted date string\n *\n * @throws `Invalid time value` if the date is invalid\n * @throws format string contains an unescaped latin alphabet character\n *\n * @example\n * const result = lightFormat(new Date(2014, 1, 11), 'yyyy-MM-dd')\n * //=> '2014-02-11'\n */\nfunction lightFormat(date, formatStr) {\n  const _date = (0, _index2.toDate)(date);\n\n  if (!(0, _index.isValid)(_date)) {\n    throw new RangeError(\"Invalid time value\");\n  }\n\n  const tokens = formatStr.match(formattingTokensRegExp);\n\n  // The only case when formattingTokensRegExp doesn't match the string is when it's empty\n  if (!tokens) return \"\";\n\n  const result = tokens\n    .map((substring) => {\n      // Replace two single quote characters with one single quote character\n      if (substring === \"''\") {\n        return \"'\";\n      }\n\n      const firstCharacter = substring[0];\n      if (firstCharacter === \"'\") {\n        return cleanEscapedString(substring);\n      }\n\n      const formatter = _index3.lightFormatters[firstCharacter];\n      if (formatter) {\n        return formatter(_date, substring);\n      }\n\n      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {\n        throw new RangeError(\n          \"Format string contains an unescaped latin alphabet character `\" +\n            firstCharacter +\n            \"`\",\n        );\n      }\n\n      return substring;\n    })\n    .join(\"\");\n\n  return result;\n}\n\nfunction cleanEscapedString(input) {\n  const matches = input.match(escapedStringRegExp);\n\n  if (!matches) {\n    return input;\n  }\n\n  return matches[1].replace(doubleQuoteRegExp, \"'\");\n}\n"]},"metadata":{},"sourceType":"script"}